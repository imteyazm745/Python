Map
A common pattern in any programming language is to transform a collection by applying a function to each element. In a procedural-looking way:

output = []
for element in iterable:
    val = function(element)
    output.append(val)

We can accomplish the same task in a declarative-looking way:

output = [
    function(element)
    for element in iterable
]
For example, if we have languages = ["python", "perl", "java", "c++"], then [len(s) for s in languages] evaluates to [6, 4, 4, 3].

But really, what are we even doing? We're just applying a function over a collection - it doesn't quite matter exactly how the collection is built up. 
In this case, Python provides us with a new function - the map function:

map(fn, iter)

The map function transforms a stream of data from an iterable and produces a stream of data by applying the function to each element
Interestingly, the first argument to map is a function object! This is the first time we've seen a function object be passed as an argument to another function.

Practically, this means that Python lets us rewrite the above example to:

map(len, languages)

The map function doesn't actual produce a list, though. It returns an object which we can consume to get the transformed values â€“ for example, we could see that:

tuple(map(len, languages))  # => (6, 4, 4, 3)
